// services/analytics.ts
interface AnalyticsEvent {
  name: string;
  params?: Record<string, any>;
  timestamp: number;
}

class AnalyticsService {
  private enabled: boolean = true;
  private queue: AnalyticsEvent[] = [];
  private isSending: boolean = false;
  private readonly MAX_RETRIES = 3;
  private readonly BATCH_SIZE = 10;
  private readonly FLUSH_INTERVAL = 30000; // 30 seconds

  constructor() {
    this.startFlushInterval();
  }

  private startFlushInterval() {
    setInterval(() => {
      this.flush();
    }, this.FLUSH_INTERVAL);
  }

  logEvent(name: string, params?: Record<string, any>): void {
    if (!this.enabled) return;

    const event: AnalyticsEvent = {
      name,
      params,
      timestamp: Date.now(),
    };

    this.queue.push(event);
    console.log(`[ANALYTICS] ${name}`, params);

    // Flush if queue reaches batch size
    if (this.queue.length >= this.BATCH_SIZE) {
      this.flush();
    }
  }

  async flush(): Promise<void> {
    if (this.isSending || this.queue.length === 0) return;

    this.isSending = true;
    const eventsToSend = [...this.queue];
    this.queue = [];

    try {
      await this.sendToServer(eventsToSend);
      console.log(`[ANALYTICS] Successfully sent ${eventsToSend.length} events`);
    } catch (error) {
      console.error('[ANALYTICS] Failed to send events:', error);
      // Re-add events to queue for retry
      this.queue.unshift(...eventsToSend);
    } finally {
      this.isSending = false;
    }
  }

  private async sendToServer(events: AnalyticsEvent[], retryCount = 0): Promise<void> {
    // Implement your analytics server endpoint here
    const response = await fetch('https://your-analytics-endpoint.com/events', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        events,
        deviceId: await this.getDeviceId(),
        sessionId: this.getSessionId(),
        appVersion: '1.0.0', // Get from app config
      }),
    });

    if (!response.ok) {
      if (retryCount < this.MAX_RETRIES) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
        return this.sendToServer(events, retryCount + 1);
      }
      throw new Error(`Analytics server responded with status: ${response.status}`);
    }
  }

  private async getDeviceId(): Promise<string> {
    // Implement device ID storage/retrieval
    const { getUniqueId } = await import('react-native-device-info');
    return getUniqueId();
  }

  private getSessionId(): string {
    // Generate or retrieve session ID
    let sessionId = localStorage?.getItem('analytics_session_id');
    if (!sessionId) {
      sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      localStorage?.setItem('analytics_session_id', sessionId);
    }
    return sessionId;
  }

  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }

  // Screen tracking
  logScreenView(screenName: string, params?: Record<string, any>): void {
    this.logEvent('screen_view', {
      screen_name: screenName,
      ...params,
    });
  }

  // User properties
  setUserProperties(properties: Record<string, any>): void {
    this.logEvent('user_properties', properties);
  }

  // Error tracking
  logError(error: Error, context?: Record<string, any>): void {
    this.logEvent('error_occurred', {
      error_message: error.message,
      error_stack: error.stack,
      error_name: error.name,
      ...context,
    });
  }

  // Performance tracking
  logPerformance(metricName: string, duration: number, metadata?: Record<string, any>): void {
    this.logEvent('performance_metric', {
      metric_name: metricName,
      duration_ms: duration,
      ...metadata,
    });
  }
}

export const analytics = new AnalyticsService();